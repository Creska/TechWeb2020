CONCEPT PLAYER-EDITOR:
* Il player avrà un foglio CSS opportuno. Tutti gli elementi del player hanno nomi standard come: "class='AnswerField' id='Quest1Activity1AnswerField'" e via dicendo. Oppure per il caso dei ligi si può utilizzare la notazione gerarchica di CSS (#Quest0 > #Activity0 per esempio)
* ESEMPIO DI STRUTTURA - con i nomi delle classi:
    * Quest
        * Activity
            * ActivityParagraph
            * AnswerField
        * Activity ...
    
* COSA DOVREBBE VEDERE IL GIOCATORE:

____________________________________
|                                   |
|            NOME STORIA            |
|___________________________________|
|                                   |
|            NOME QUEST             |
|___________________________________|
|                                   |
|        testo, immagini, ecc.      |
|                                   |
.                                   .
.                                   .
.                                   .
|                                   |
| CAMPO RISPOSTA DI FINE ATTIVITA'  |
|___________________________________|

APPUNTO IMPORTANTE PER window.close() --> https://stackoverflow.com/questions/19761241/window-close-and-self-close-do-not-close-the-window-in-chrome

BUG E PROBLEMI DA CORREGGERE
* EDITOR
    * [WIP] Chiamate AJAX
        * salvataggio
        * caricamento
        * cancellazione
        * pubblicazione (qui va inserita creazione degli id per quest e storia e generazione qrcode)
        * ritiro
        * interfaccia
    * [WAITING] Funzioni di passaggio per navbar e main menu
    * Mettere il nome dell'app
* PLAYER
    * Sistemare grafica
    * [WIP] Chiamate AJAX
        * caricamento (va inserita anche la divisione in gruppi)
        * invio stats a fine attività
        * invio stats ogni 5s
        * richiesta valutazione umana
    * Riprogettare eventualmente l'interfaccia (ad esempio mettere un header per il campo risposta) - nel caso va rifatta la guida dell'editor CSS
    * Aggiungere una funzione che segnali allo screenreader se bisogna ripetere l'attività corrente
* ORGANIZZAZIONE
    * Definire il sistema di cartelle - dove vengono salvati i media e il CSS personalizzato
* STORIE DI PROVA
    * Completare

APPUNTI su roba da fare:
* al salvataggio bisogna inviare un array di oggetti. per ogni file un oggetto: {namestring, is_story_json, buffer}
* per inviare le stats "/player/activityUpdate"
* ChatMessages e score per ogni attività ( quindi ad ogni attività viene resettato )
* ogni volta che un'attività viene finita vengono inviate le stats
* timer ogni 5s che fa una post dove passo: (QuestID, ActivityN, time_elapsed)
* groupID per sapere il nome del gruppo

ACESSIBILITA'
* header: role='heading' aria-level=numero come nel tag



appunti:
* get() --> utilizzato per la query
* res --> parametro per la risposta da restituire al client
* al caricamento della pagina del player viene aggiunto nell'head un template per il json
* la sintassi $(function()) è uno shortcut per window.onload
* per avviare un app in Node basta fare node app.js dal cmd
* link utili per accessibilità:
    * https://developer.paciellogroup.com/blog/2017/04/what-is-an-accessible-name/
    * https://www.w3.org/1999/xhtml/vocab#XHTMLRoleVocabulary
    * https://webaim.org/techniques/aria/#rules
* margin per elementi div: https://stackoverflow.com/questions/35817096/css-margin-0-auto-not-centering
* leggere files con javascript:
    * https://web.dev/read-files/#select-input
    * https://www.youtube.com/watch?v=VElnT8EoEEM
* footer:
    * https://philipwalton.github.io/solved-by-flexbox/demos/sticky-footer/
    * https://stackoverflow.com/questions/29069498/how-to-make-a-sticky-footer-using-css